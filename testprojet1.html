<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <title>Phaser Waves + Text Generator (Pro Edition)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.85.0/dist/phaser.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            background: #b8ffb8;
            display: flex;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }

        /* Zone Phaser à gauche */
        #phaser-example {
            flex-grow: 1;
            width: 70vw;
            height: 100vh;
        }

        /* Zone interface à droite */
        #right-panel {
            width: 30vw;
            min-width: 300px; /* Ensure panel is usable on smaller screens */
            height: 100vh;
            background: #ffffffaa;
            padding: 20px;
            box-sizing: border-box;
            backdrop-filter: blur(5px);
            z-index: 10;
        }

        #right-panel h2 {
            margin-top: 0;
            color: #ff3eb5;
            font-size: 28px;
            text-align: center;
        }

        #text-input {
            width: 100%;
            padding: 12px;
            font-size: 18px;
            margin-bottom: 15px;
            border: 2px solid #ff3eb5;
            border-radius: 10px;
            outline: none;
        }

        #generate-btn {
            width: 100%;
            padding: 12px;
            background: #ff3eb5;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 20px;
            cursor: pointer;
            transition: background 0.2s;
        }

        #generate-btn:hover {
            background: #ff1ea0;
        }

        #phaser-text {
            margin-top: 30px;
            height: 60vh;
            border: 2px dashed #ff3eb5;
            border-radius: 10px;
            padding: 10px;
            color: #ff3eb5;
            overflow-y: auto;
            font-size: 14px;
        }
        
        #code-output {
            white-space: pre-wrap; /* Ensures code wraps within the box */
            word-wrap: break-word;
        }
    </style>
</head>

<body>

    <div id="phaser-example"></div>

    <div id="right-panel">
        <h2>Créer une animation avec ton texte</h2>
        <input id="text-input" type="text" placeholder="Écris un mot ou une phrase…" value="PHASER WAVES">
        <button id="generate-btn">Générer l’animation</button>

        <div id="phaser-text">
            Code généré : <br>
            <pre id="code-output"></pre>
        </div>
    </div>

    <script>
        // --- SCENE CLASS: Example ---
        class Example extends Phaser.Scene {
            // Class properties for cleaner syntax and easier access
            blocks;
            originalPositions;
            letters = [];
            isDragging = false;
            
            // Animation state
            phase = 0;
            phaseDuration = 6000;
            timeSincePhase = 0;

            constructor() {
                super({ key: 'Example' });
            }

            // A utility function to ensure responsiveness
            updateGameSize() {
                const width = Math.floor(window.innerWidth * 0.70);
                const height = Math.floor(window.innerHeight);
                this.scale.resize(width, height);
                this.resizeBlocks(width, height);
            }

            preload() {
                // Ensure all keys are consistent with the asset path fix
                this.load.image('square', 'assets/sprites/50x50.png');
                this.load.image('circle', 'assets/sprites/blue_ball.png');
                this.load.image('diamond', 'assets/sprites/diamond.png');
                this.load.image('spark', 'assets/particles/blue.png');
                this.load.audio('pop', 'assets/audio/SoundEffects/pop.wav'); 
            }

            create() {
                this.input.mouse.disableContextMenu(); // Good practice for web games
                this.particles = this.add.particles("spark").setDepth(1);

                this.createBlocks();
                this.createTextEngine();

                // Input Listeners
                this.input.on('pointerdown', this.handleInputStart, this);
                this.input.on('pointerup', this.handleInputStop, this);
                
                // Responsive Resize Handler
                window.addEventListener('resize', this.updateGameSize.bind(this));
            }
            
            // --- BLOCK GRID METHODS ---

            createBlocks() {
                const shapes = ["square", "circle", "diamond"];
                const blocks = this.add.group();

                for (let i = 0; i < 108; i++) {
                    const shape = shapes[i % shapes.length];
                    const child = this.add.image(0, 0, shape).setScale(0.3);
                    child.setTint(0xff3eb5);

                    child.setInteractive();
                    child.on("pointerdown", this.handleBlockClick, this);
                    child.on("pointerover", this.handleBlockHover, this);
                    
                    blocks.add(child);
                }

                this.blocks = blocks;
                // Store initial positions once
                this.originalPositions = blocks.getChildren().map(b => ({ x: b.x, y: b.y }));
                this.resizeBlocks(this.scale.width, this.scale.height);
            }

            resizeBlocks(gameWidth, gameHeight) {
                // Adjust position based on new screen size
                Phaser.Actions.GridAlign(this.blocks.getChildren(), {
                    width: 12,
                    height: 9,
                    cellWidth: 60,
                    cellHeight: 60,
                    // Center the grid in the canvas
                    x: (gameWidth - (12 * 60)) / 2 + 30,
                    y: (gameHeight - (9 * 60)) / 2 + 30
                });
                // Update original positions based on new grid alignment
                this.originalPositions = this.blocks.getChildren().map(b => ({ x: b.x, y: b.y }));
            }

            handleBlockHover(child) {
                 this.tweens.add({
                    targets: child,
                    scale: 0.5,
                    duration: 150,
                    yoyo: true,
                    ease: 'Quad.easeOut'
                });
            }

            handleBlockClick(pointer, child) {
                this.playPopSound(); 

                this.particles.createEmitter({
                    x: child.x,
                    y: child.y,
                    speed: { min: -150, max: 150 },
                    lifespan: 500,
                    scale: { start: 0.5, end: 0 },
                    quantity: 25,
                    tint: 0xff3eb5
                });
            }

            playPopSound() {
                // Check if sound manager exists and the key is loaded
                if (this.sound && this.sound.keyExists('pop')) {
                    try {
                        this.sound.play('pop');
                    } catch (e) {
                        console.warn('Could not play sound:', e);
                    }
                } else {
                     console.warn('Sound key "pop" not loaded or does not exist.');
                }
            }
            
            handleInputStart() {
                this.isDragging = true;
            }

            handleInputStop() {
                this.isDragging = false;
            }

            // --- UPDATE LOOP & ANIMATION ---

            update(time, delta) {
                // Update block animation phase
                this.timeSincePhase += delta;
                
                // Changed from % 4 to % 5 to accommodate the new clean phase (Phase 4)
                if (this.timeSincePhase > this.phaseDuration) {
                    this.phase = (this.phase + 1) % 5; 
                    this.timeSincePhase = 0;
                }

                // 1. Block Movement (for mouse drag)
                if (this.isDragging) {
                    const mx = this.input.activePointer.x;
                    const my = this.input.activePointer.y;
                    
                    this.blocks.getChildren().forEach(block => {
                        const angle = Phaser.Math.Angle.Between(block.x, block.y, mx, my);
                        block.x += Math.cos(angle) * 0.8;
                        block.y += Math.sin(angle) * 0.8;
                    });
                }

                // 2. Continuous Block Animation
                this.animateBlocks(time);
                
                // 3. Continuous Text Animation
                this.animateWaveText(time); 
            }

            animateBlocks(time) {
                const blocks = this.blocks.getChildren();
                const centerX = this.scale.width / 2;
                const centerY = this.scale.height / 2;

                blocks.forEach((block, i) => {
                    const orig = this.originalPositions[i];
                    
                    // Restore position if not dragging (simple spring-back)
                    if (!this.isDragging) {
                        block.x = Phaser.Math.Linear(block.x, orig.x, 0.05);
                        block.y = Phaser.Math.Linear(block.y, orig.y, 0.05);
                    }


                    switch (this.phase) {
                        
                        // PHASE 0: EXPAND FROM CENTER (Requested Animation)
                        case 0:
                            const dx = orig.x - centerX;
                            const dy = orig.y - centerY;
                            const angle = Math.atan2(dy, dx);
                            
                            // Use distance to create phase lag, use time for movement
                            const distFromCenter = Math.sqrt(dx * dx + dy * dy); 
                            
                            // Sine wave for expanding/contracting distance
                            const offsetMag = Math.sin(time / 400 + distFromCenter * 0.01) * 35; // 35 is max displacement
                            
                            // Apply offset along the original angle from the center
                            block.x = orig.x + Math.cos(angle) * offsetMag;
                            block.y = orig.y + Math.sin(angle) * offsetMag;
                            break;
                            
                        // Phase 1: Radial Wave (Original Code)
                        case 1:
                            const dx1 = orig.x - centerX;
                            const dy1 = orig.y - centerY;
                            const dist = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                            const offset = Math.sin(time / 250 + dist * 0.05) * 18;
                            block.x = orig.x + dx1 * 0.03 * Math.sin(time / 500);
                            block.y = orig.y + offset;
                            break;
                        
                        // Phase 2: Diagonal Wave (Original Code)
                        case 2:
                            const offset2 = Math.sin(time / 220 + (orig.x + orig.y) * 0.06) * 15;
                            block.x = orig.x + offset2;
                            block.y = orig.y + offset2 * 0.5;
                            break;
                        
                        // Phase 3: Chaotic/Individual Wave (Original Code)
                        case 3:
                            const offset3 = Math.sin(time / 150 + i * 0.5) * (8 + (i % 18));
                            block.x = orig.x + offset3 * 0.8;
                            block.y = orig.y + offset3;
                            break;
                            
                        // PHASE 4: RETURN TO ORIGINAL POSITION (Clean State)
                        case 4:
                            // Stops further animation offsets; the isDragging check handles the smooth return
                            block.x = orig.x;
                            block.y = orig.y;
                            break;
                    }
                });
            }

            // --- TEXT ENGINE METHODS ---

            createTextEngine() {
                const input = document.getElementById("text-input");
                const button = document.getElementById("generate-btn");
                const codeOutput = document.getElementById("code-output");

                button.addEventListener("click", () => {
                    const textValue = input.value.toUpperCase();
                    this.generateAnimatedText(textValue);
                    this.generateCodeSnippet(textValue);
                });

                // Generate initial text
                this.generateAnimatedText(input.value.toUpperCase());
                this.generateCodeSnippet(input.value.toUpperCase());
            }

            generateAnimatedText(text) {
                if (!text) return;

                const startX = this.scale.width * 0.75; 
                const startY = this.scale.height / 2 - (text.length * 20); 

                if (this.letters.length > 0) {
                    this.letters.forEach(l => {
                        this.tweens.killTweensOf(l);
                        l.destroy();
                    });
                    this.letters = [];
                }

                [...text].forEach((char, i) => {
                    const letter = this.add.text(
                        startX, 
                        startY + i * 45, 
                        char, 
                        {
                            fontFamily: 'Arial Black', 
                            fontSize: '60px',
                            color: '#000000',
                            stroke: '#ff3eb5',
                            strokeThickness: 8,
                        }
                    ).setOrigin(0.5);

                    letter.waveIndex = i; 
                    this.letters.push(letter);
                });
            }

            animateWaveText(time) {
                // Optimized wave animation (sine wave on X position)
                if (this.letters.length === 0) return;
                
                const amplitude = 30; // Max wave distance
                const frequency = 0.3; // How spread out the wave is

                this.letters.forEach((letter) => {
                    // Calculate the target wave X position
                    const waveX = Math.sin(time * 0.005 + letter.waveIndex * frequency) * amplitude;
                    
                    // Use simple linear easing to smoothly move the letter towards the target
                    letter.x = letter.x - (letter.x - (this.scale.width * 0.75 + waveX)) * 0.1; 
                });
            }
            
            // --- CODE GENERATION ---

            generateCodeSnippet(text) {
                const code = `
// 1. Define Scene Property
// this.waveLetters; 

// 2. Create Text (in 'create()' function)
this.waveLetters = [];
const startX = 400; // Your desired X position
const startY = 100; // Starting Y position
const textToAnimate = "${text}";

[...textToAnimate].forEach((char, i) => {
    const letter = this.add.text(startX, startY + i * 45, char, {
        fontFamily: 'Arial Black', 
        fontSize: '60px',
        color: '#000000',
        stroke: '#ff3eb5',
        strokeThickness: 8,
    }).setOrigin(0.5);
    letter.waveIndex = i;
    this.waveLetters.push(letter);
});

// 3. Animation Loop (in 'update(time, delta)' function)
if (this.waveLetters) {
    const amplitude = 30;
    const frequency = 0.3;
    const centerLineX = 400; // Must match startX from step 2

    this.waveLetters.forEach((letter) => {
        const waveX = Math.sin(time * 0.005 + letter.waveIndex * frequency) * amplitude;
        // Apply smooth movement towards the new wave position
        letter.x = Phaser.Math.Linear(letter.x, centerLineX + waveX, 0.1); 
    });
}
                `.trim();

                document.getElementById("code-output").textContent = code;
            }
        }

        // --- GAME CONFIG ---
        const config = {
            type: Phaser.AUTO,
            // Calculate initial dimensions based on the 70vw CSS rule
            width: Math.floor(window.innerWidth * 0.70), 
            height: Math.floor(window.innerHeight),
            backgroundColor: '#b8ffb8',
            parent: 'phaser-example',
            scene: Example,
            dom: {
                createContainer: true
            }
        };

        new Phaser.Game(config);
    </script>

</body>

</html>
