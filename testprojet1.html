      this.clearAnimatedText();
    });
  }

  updateHistoryUI() {
    const historyList = document.getElementById('history-list');
    historyList.innerHTML = '';

    this.history.forEach(text => {
      const item = document.createElement('div');
      item.className = 'history-item';
      if (text === this.currentAnimationText) {
        item.classList.add('active');
      }
      item.textContent = text;
      
      item.addEventListener('click', () => {
        this.generateAnimatedText(text);
        this.currentAnimationText = text;
        this.updateHistoryUI();
      });

      historyList.appendChild(item);
    });
  }

  generateAnimatedText(text) {
    // Clear previous text
    if (this.textLetters) {
      this.textLetters.forEach(letter => letter.destroy());
    }
    this.textLetters = [];

    if (!text) return;

    // Center position
    const centerX = this.cameras.main.width / 2;
    const centerY = this.cameras.main.height / 2;
    
    const charWidth = 35;
    const totalWidth = text.length * charWidth;
    const startX = centerX - totalWidth / 2;

    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      const xPos = startX + i * charWidth;
      
      const letter = this.add.text(xPos, centerY, char, {
        fontFamily: 'Arial, sans-serif',
        fontSize: '48px',
        fontWeight: 'bold',
        color: '#ffffff',
        stroke: '#667eea',
        strokeThickness: 2
      }).setOrigin(0.5).setDepth(100);

      this.textLetters.push(letter);

      // Animate each letter
      this.tweens.add({
        targets: letter,
        y: centerY - 15,
        angle: 360,
        alpha: 1,
        duration: 1000 + i * 50,
        ease: 'elastic.out',
        repeat: 0
      });

      // Continuous floating animation
      this.tweens.add({
        targets: letter,
        y: centerY + 10,
        duration: 2000 + i * 100,
        ease: 'sine.inout',
        delay: 1000 + i * 50,
        yoyo: true,
        repeat: -1
      });
    }
  }

  clearAnimatedText() {
    if (this.textLetters) {
      this.textLetters.forEach(letter => letter.destroy());
      this.textLetters = [];
    }
  }

  setupAudio() {
    const audioToggle = document.getElementById('audio-toggle');
    
    try {
      const ambientMusic = this.sound.add('ambient', { loop: true, volume: 0.3 });
      
      audioToggle.addEventListener('click', () => {
        this.audioEnabled = !this.audioEnabled;
        audioToggle.classList.toggle('active');
        
        if (this.audioEnabled) {
          if (!ambientMusic.isPlaying) {
            ambientMusic.play();
          }
        } else {
          ambientMusic.stop();
        }
      });

      // Auto-play with muted state
      ambientMusic.play().catch(() => {
        // Browser autoplay policy - user must interact
      });
    } catch (e) {
      console.log('Audio setup skipped');
    }
  }

  setupInput() {
    // Mouse flee effect
    this.input.on('pointermove', (pointer) => {
      if (!this.blocks) return;

      this.blocks.getChildren().forEach(block => {
        const angle = Phaser.Math.Angle.Between(block.x, block.y, pointer.x, pointer.y);
        const distance = Phaser.Math.Distance.Between(block.x, block.y, pointer.x, pointer.y);
        
        // Flee effect - stronger when closer
        if (distance < 200) {
          const fleeForce = (200 - distance) / 200 * 2;
          block.x += Math.cos(angle + Math.PI) * fleeForce;
          block.y += Math.sin(angle + Math.PI) * fleeForce;
        }
      });
    });
  }

  update(time, delta) {
    if (!this.blocks) return;

    // Update phase
    this.timeSincePhase += delta;
    if (this.timeSincePhase > this.phaseDuration) {
      this.currentPhase = (this.currentPhase + 1) % this.shapes.length;
      this.timeSincePhase = 0;

      this.blocks.getChildren().forEach(block => {
        block.setTexture(this.shapes[this.currentPhase]);
      });
    }

    // Animate blocks
    this.animateBlocks(time);
    
    // Keep blocks in bounds
    this.keepBlocksInBounds();
  }

  animateBlocks(time) {
    this.blocks.getChildren().forEach((block, i) => {
      const orig = this.originalPositions[i];
      let offsetX = 0;
      let offsetY = 0;

      // HORIZONTAL animation patterns
      switch (this.currentPhase) {
        case 0: // Wave effect - horizontal
          offsetX = Math.sin(time / 300 + orig.y * 0.12) * 15;
          offsetY = Math.cos(time / 400 + orig.x * 0.08) * 8;
          break;
        case 1: // Radial pulse - horizontal
          const dx = orig.x - 400;
          const dy = orig.y - 300;
          const dist = Math.sqrt(dx * dx + dy * dy);
          offsetX = Math.sin(time / 250 + dist * 0.05) * 20;
          offsetY = Math.cos(time / 350 + dist * 0.03) * 12;
          break;
        case 2: // Spiral effect - horizontal
          offsetX = Math.sin(time / 220 + (orig.x + orig.y) * 0.06) * 18;
          offsetY = Math.cos(time / 280 + (orig.x - orig.y) * 0.05) * 15;
          break;
      }

      block.x = orig.x + offsetX;
      block.y = orig.y + offsetY;
    });
  }

  keepBlocksInBounds() {
    const padding = 100;
    const bounds = this.cameras.main.getBounds();

    this.blocks.getChildren().forEach((block, i) => {
      const orig = this.originalPositions[i];
      
      // Clamp to bounds
      if (block.x < bounds.left - padding) block.x = bounds.left - padding;
      if (block.x > bounds.right + padding) block.x = bounds.right + padding;
      if (block.y < bounds.top - padding) block.y = bounds.top - padding;
      if (block.y > bounds.bottom + padding) block.y = bounds.bottom + padding;
    });
  }
}

// Phaser configuration
const config = {
  type: Phaser.AUTO,
  width: window.innerWidth * 0.75,
  height: window.innerHeight,
  backgroundColor: '#667eea',
  parent: 'phaser-example',
  scene: AnimationScene,
  render: {
    antialias: true,
    antialiasGL: true,
    pixelArt: false
  },
  physics: {
    default: 'arcade',
    arcade: {
      debug: false
    }
  }
};

const game = new Phaser.Game(config);

// Handle window resize
window.addEventListener('resize', () => {
  game.scale.resize(window.innerWidth * 0.75, window.innerHeight);
});
</script>

</body>
</html>
