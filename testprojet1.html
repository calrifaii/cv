<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Phaser Shapes + Text Generator with History</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.85.0/dist/phaser.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      font-family: Arial, sans-serif;
      overflow: hidden;
      background: #b8ffb8;
    }

    /* Phaser zone */
    #phaser-example {
      width: 70vw;
      height: 100vh;
    }

    /* Right-side interface */
    #right-panel {
      width: 30vw;
      height: 100vh;
      background: rgba(255,255,255,0.95);
      padding: 20px;
      box-sizing: border-box;
      backdrop-filter: blur(5px);
      overflow: auto;
      display: flex;
      flex-direction: column;
    }

    #right-panel h2 {
      margin-top: 0;
      color: #ff3eb5; /* Default/Pink color */
      font-size: 22px;
      text-align: center;
      margin-bottom: 15px;
    }

    #text-input {
      width: 100%;
      padding: 10px;
      font-size: 16px;
      margin-bottom: 12px;
      border: 2px solid #ff3eb5;
      border-radius: 8px;
      outline: none;
      transition: all 0.3s ease;
    }

    #text-input:focus {
      box-shadow: 0 0 10px rgba(255, 62, 181, 0.3);
      transform: translateY(-2px);
    }

    #generate-btn {
      width: 100%;
      padding: 10px;
      background: #ff3eb5;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 600;
      margin-bottom: 15px;
    }

    #generate-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(255, 62, 181, 0.3);
    }

    #generate-btn:active {
      transform: translateY(0);
    }

    /* Color Picker Section */
    .color-picker {
      margin-bottom: 20px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 8px;
    }

    .color-picker-title {
      font-size: 14px;
      font-weight: 700;
      color: #333;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
    }

    #color-options {
      display: flex;
      justify-content: space-around;
    }

    .color-swatch {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: 3px solid transparent;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    .color-swatch:hover {
      transform: scale(1.1);
    }

    .color-swatch.active {
      border-color: #333;
      transform: scale(1.1);
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }

    /* History Section */
    .history-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      margin-top: 10px;
    }

    .history-title {
      font-size: 14px;
      font-weight: 700;
      color: #ff3eb5;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 10px;
    }

    #history-list {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
      overflow-y: auto;
      margin-bottom: 10px;
    }

    #history-list::-webkit-scrollbar {
      width: 6px;
    }

    #history-list::-webkit-scrollbar-track {
      background: rgba(255, 62, 181, 0.1);
      border-radius: 10px;
    }

    #history-list::-webkit-scrollbar-thumb {
      background: #ff3eb5;
      border-radius: 10px;
    }

    .history-item {
      padding: 10px;
      background: rgba(255, 62, 181, 0.08);
      border: 1px solid rgba(255, 62, 181, 0.2);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 12px;
      color: #333;
      word-break: break-word;
      font-weight: 500;
    }

    .history-item:hover {
      background: rgba(255, 62, 181, 0.15);
      border-color: #ff3eb5;
      transform: translateX(3px);
    }

    .history-item.active {
      background: #ff3eb5;
      color: white;
      border-color: #ff3eb5;
      font-weight: 600;
    }

    .clear-history-btn {
      width: 100%;
      padding: 8px;
      background: rgba(255, 62, 181, 0.1);
      color: #ff3eb5;
      border: 1px solid #ff3eb5;
      border-radius: 6px;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .clear-history-btn:hover {
      background: #ff3eb5;
      color: white;
    }

    #phaser-text {
      display: none;
    }
  </style>
</head>
<body>

<div id="phaser-example"></div>

<div id="right-panel">
  <h2>Créer une animation avec ton texte</h2>

  <div class="color-picker">
    <div class="color-picker-title">Choisis une couleur :</div>
    <div id="color-options">
          </div>
  </div>
  
  <input id="text-input" type="text" placeholder="Écris un mot ou une phrase…" maxlength="20">
  <button id="generate-btn">Générer l'animation</button>

  <div class="history-section">
    <div class="history-title">Historique</div>
    <div id="history-list"></div>
    <button class="clear-history-btn" id="clear-history-btn">Effacer l'historique</button>
  </div>

  <div id="phaser-text"></div>
</div>

<script>
class Example extends Phaser.Scene {
  constructor() {
    super();
    this.colorConfigs = {
      'pink': { hex: 0xff3eb5, style: { color: '#ff3eb5', fontFamily: 'Arial', fontWeight: 'bold' }, shapeIndex: 0 },
      'blue': { hex: 0x3e8aff, style: { color: '#3e8aff', fontFamily: 'Verdana', fontWeight: 'bold' }, shapeIndex: 1 },
      'yellow': { hex: 0xffe83e, style: { color: '#888800', fontFamily: 'Impact', fontWeight: 'bold' }, shapeIndex: 2 },
      'green': { hex: 0x3eff8a, style: { color: '#008800', fontFamily: 'Courier New', fontWeight: 'bold' }, shapeIndex: 3 },
      'red': { hex: 0xff3e3e, style: { color: '#ff3e3e', fontFamily: 'Times New Roman', fontWeight: 'bold' }, shapeIndex: 4 }
    };
    this.currentTheme = 'pink'; // Thème par défaut
    this.phaseDuration = 6000;
    this.timeSincePhase = 0;
    this.history = [];
    this.currentAnimationText = '';
    this.popSound = null;
    this.shapes = ['square','circle','diamond','triangle','star']; 
    this.letters = []; // Liste des éléments de texte actuels
    this.oldLetters = []; // Liste des éléments de texte précédents pour l'animation de sortie
  }

  preload() {
    this.load.setBaseURL('https://labs.phaser.io');
    this.load.image('spark', 'assets/particles/blue.png');
    this.load.audio('pop', 'assets/audio/SoundEffects/pop.wav');
  }

  create() {
    this.createShapeTextures();
    this.createBlocks();
    this.setupBlockInteractions();
    this.createTextEngine();
    this.setupMouseFleeEffect();
    this.setupAudio();
    this.setupColorPicker(); 
    this.applyTheme(this.currentTheme); 
  }
  
  createShapeTextures(){
    var g = this.make.graphics({ x:0, y:0, add:false });
    var size = 50;

    // Square (index 0)
    g.fillStyle(0xffffff,1);
    g.fillRect(0,0,size,size);
    g.generateTexture('square',size,size);

    // Circle (index 1)
    g.clear();
    g.fillStyle(0xffffff,1);
    g.fillCircle(size/2,size/2,size/2);
    g.generateTexture('circle',size,size);

    // Diamond (index 2)
    g.clear();
    g.fillStyle(0xffffff,1);
    g.beginPath();
    g.moveTo(size/2,0);
    g.lineTo(size,size/2);
    g.lineTo(size/2,size);
    g.lineTo(0,size/2);
    g.closePath();
    g.fillPath();
    g.generateTexture('diamond',size,size);

    // Triangle (index 3)
    g.clear();
    g.fillStyle(0xffffff,1);
    g.beginPath();
    g.moveTo(size/2, 0);
    g.lineTo(size, size);
    g.lineTo(0, size);
    g.closePath();
    g.fillPath();
    g.generateTexture('triangle', size, size);

    // Star (index 4) - Simplified as a smaller, rotating square for difference
    g.clear();
    g.fillStyle(0xffffff,1);
    g.fillRect(15,15,20,20);
    g.generateTexture('star', size, size);
  }
  
  createBlocks(){
    var gameWidth = this.cameras.main.width;
    var gameHeight = this.cameras.main.height;
    var cellWidth = 60;
    var cellHeight = 60;
    var cols = Math.ceil(gameWidth / cellWidth) + 1;
    var rows = Math.ceil(gameHeight / cellHeight) + 1;
    var totalBlocks = cols * rows;

    var blocks = this.add.group();
    for(var i=0;i<totalBlocks;i++){
      var key = this.shapes[i%this.shapes.length];
      var sprite = this.add.image(0,0,key).setScale(0.3);
      sprite.setInteractive();
      blocks.add(sprite);
    }

    Phaser.Actions.GridAlign(blocks.getChildren(), { width:cols, height:rows, cellWidth:cellWidth, cellHeight:cellHeight, x:0, y:0 });

    this.blocks = blocks;
    this.originalPositions = blocks.getChildren().map(function(b){return {x:b.x, y:b.y};});
    this.particles = this.add.particles('spark');
    
    this.cols = cols;
  }

  setupBlockInteractions(){
    var self=this;
    this.blocks.getChildren().forEach(function(block){
      block.on('pointerover', function(){ self.tweens.add({targets:block, scale:0.5, duration:150, yoyo:true}); });
      block.on('pointerdown', function(){ 
        self.blockHit(block);
      });
    });
  }
  
  blockHit(block){
    if(this.popSound){ try{this.popSound.play();}catch{} }
    var hexColor = this.colorConfigs[this.currentTheme].hex;
    this.particles.createEmitter({x:block.x, y:block.y, speed:{min:-150,max:150}, lifespan:500, scale:{start:0.5,end:0}, quantity:20, tint:hexColor}).explode(20, block.x, block.y);
  }

  applyTheme(themeName){
    var config = this.colorConfigs[themeName];
    var hex = config.hex;
    this.currentTheme = themeName;
    this.timeSincePhase = 0; 

    // 1. Mettre à jour les couleurs des blocs et la texture de base
    var shapeKey = this.shapes[config.shapeIndex % this.shapes.length];
    this.blocks.getChildren().forEach(function(block){ 
      block.setTexture(shapeKey);
      block.setTint(hex);
    });

    // 2. Mettre à jour l'animation de texte si elle est visible
    if(this.currentAnimationText){
      // Régénère le texte pour appliquer le nouveau style/couleur sans animation de transition
      this.generateAnimatedText(this.currentAnimationText, { instant: true }); 
    }

    // 3. Mettre à jour l'historique UI
    this.updateHistoryUI();
    
    // 4. Mettre à jour l'interface
    document.getElementById('generate-btn').style.background = config.style.color;
    document.getElementById('generate-btn').style.boxShadow = `0 5px 15px rgba(${hex>>16 & 0xFF}, ${(hex>>8) & 0xFF}, ${hex & 0xFF}, 0.3)`;
    document.getElementById('text-input').style.borderColor = config.style.color;
    document.querySelector('#right-panel h2').style.color = config.style.color;
    document.querySelector('.history-title').style.color = config.style.color;
    document.querySelector('#clear-history-btn').style.color = config.style.color;
    document.querySelector('#clear-history-btn').style.borderColor = config.style.color;

    // 5. Mettre à jour les indicateurs de sélection de couleur
    document.querySelectorAll('.color-swatch').forEach(swatch => {
      if(swatch.dataset.color === themeName){
        swatch.classList.add('active');
      } else {
        swatch.classList.remove('active');
      }
    });
  }

  setupColorPicker(){
    var colorOptions = document.getElementById('color-options');
    var self = this;

    for(var themeName in this.colorConfigs){
      (function(themeName, config){
        var swatch = document.createElement('div');
        swatch.className = 'color-swatch';
        swatch.style.backgroundColor = config.style.color;
        swatch.dataset.color = themeName;
        
        swatch.addEventListener('click', function(){
          self.applyTheme(themeName);
        });

        colorOptions.appendChild(swatch);
      })(themeName, this.colorConfigs[themeName]);
    }
  }


  update(time, delta) {
    
    if(this.input.activePointer.isDown){
      var mx=this.input.x, my=this.input.y;
      this.blocks.getChildren().forEach(function(block){
        var angle=Phaser.Math.Angle.Between(block.x, block.y, mx, my);
        block.x += Math.cos(angle)*0.6;
        block.y += Math.sin(angle)*0.6;
      });
    }

    this.animateBlocks(time);
  }

  animateBlocks(time){
    var self=this;
    var config = self.colorConfigs[self.currentTheme];
    var phase = config.shapeIndex;

    this.blocks.getChildren().forEach(function(block,i){
      var orig=self.originalPositions[i];
      var offsetX=0, offsetY=0;
      
      // Différents schémas d'animation basés sur la phase/couleur
      switch(phase){
        case 0: // Pink - Waves in both axis
          offsetX=Math.sin(time/300 + orig.y*0.12)*12; 
          offsetY=Math.cos(time/400 + orig.x*0.08)*8;
          block.angle = Math.sin(time/500)*5;
          break;
        case 1: // Blue - Circular/spiral movement
          var dist=Phaser.Math.Distance.Between(orig.x, orig.y, 400, 300);
          offsetX=Math.sin(time/400 + dist*0.05)*18; 
          offsetY=Math.cos(time/400 + dist*0.05)*18;
          block.angle = time/50 % 360;
          break;
        case 2: // Yellow - Diagonal / Swirling
          offsetX=Math.sin(time/220 + (orig.x+orig.y)*0.06)*15; 
          offsetY=Math.cos(time/280 + (orig.x-orig.y)*0.05)*10;
          block.angle = Math.sin(time/300)*10;
          break;
        case 3: // Green - Vertical/Horizontal only (Grid)
          offsetX=Math.sin(time/350 + orig.y*0.1) * 10;
          offsetY=Math.sin(time/350 + orig.x*0.1) * 10;
          block.angle = 0;
          break;
        case 4: // Red - Random shake/pulse
          offsetX=Math.sin(time/100 + i)*5;
          offsetY=Math.cos(time/120 + i)*5;
          block.angle = Math.random() * 5 - 2.5;
          break;
        default: // Fallback to original
          offsetX=Math.sin(time/300 + orig.y*0.12)*12; 
          offsetY=Math.cos(time/400 + orig.x*0.08)*8;
          block.angle = 0;
          break;
      }
      
      block.x = orig.x + offsetX;
      block.y = orig.y + offsetY;
    });
  }
  
  // Nouvelle fonction pour gérer l'animation de sortie
  animateOldTextOut(){
    if(this.oldLetters && this.oldLetters.length > 0){
      var gameWidth = this.cameras.main.width;
      var self = this;
      
      this.oldLetters.forEach(function(item, idx){
        // Lancer l'animation de sortie vers la droite
        self.tweens.add({
          targets: item,
          x: gameWidth + 50, // Déplace l'élément juste à l'extérieur de l'écran à droite
          alpha: 0,
          duration: 300, // Durée rapide
          ease: 'Quad.easeIn',
          delay: idx * 20, // Petit délai pour un effet d'échelonnage
          onComplete: function(){
            item.destroy();
          }
        });
      });
      this.oldLetters = []; // Vider la liste
    }
  }

  generateAnimatedText(text, options = { instant: false }){
    if(!text) return;
    
    // 1. Déplacer et détruire l'ancien texte AVANT de créer le nouveau
    if(this.letters.length > 0){
      this.oldLetters = this.letters;
      if(!options.instant){
        this.animateOldTextOut();
      } else {
        // Destruction immédiate si on change juste le thème
        this.oldLetters.forEach(function(l){l.destroy();});
        this.oldLetters = [];
      }
    }
    
    this.letters=[]; // Préparer la nouvelle liste de lettres

    var config = this.colorConfigs[this.currentTheme];
    var style = { ...config.style, fontSize:'40px' }; 
    var bgColor = Phaser.Display.Color.HexStringToColor('#b8ffb8').color; 

    var gameWidth = this.cameras.main.width;
    var centerY = this.cameras.main.height / 2;
    
    var charWidth = 45; 
    var totalWidth = text.length * charWidth;
    var centerX = this.cameras.main.width / 2;
    var targetStartX = centerX - totalWidth / 2 + charWidth/2;
    
    var self = this;
    for(var i=0;i<text.length;i++){
      (function(self,ch,idx){
        var targetX = targetStartX + idx * charWidth;
        var startX = -50; // Point de départ hors écran à gauche
        
        // Créer le cercle de fond
        var bgCircle = self.add.circle(startX, centerY, 35, bgColor, 0.8).setDepth(99).setStrokeStyle(3, config.hex, 1);
        self.letters.push(bgCircle);
        
        // Créer le texte
        var letter=self.add.text(startX, centerY, ch, style).setOrigin(0.5).setDepth(100);
        self.letters.push(letter);
        
        var baseDelay = 100;
        var indexDelay = idx * 30;

        if(!options.instant){
          // *** NOUVELLE ANIMATION D'ENTRÉE (GAUCHE -> CENTRE) ***
          
          // Animation pour le fond et la lettre
          self.tweens.add({
            targets: [bgCircle, letter],
            x: targetX,
            duration: 350, // Haute vitesse
            ease: 'Quad.easeOut', 
            delay: baseDelay + indexDelay,
            onComplete: function(){
              // Une fois l'entrée terminée, lance l'animation de flottement continue
              self.addContinuousFloatAnimation(bgCircle, letter, targetX, centerY, config.shapeIndex, idx);
            }
          });
          
          // Animation de zoom au début de l'entrée (pour le BG et la lettre)
          bgCircle.setScale(0.5);
          letter.setScale(0.5);
          self.tweens.add({
            targets: [bgCircle, letter],
            scale: 1, 
            duration: 350,
            ease: 'Quad.easeOut',
            delay: baseDelay + indexDelay,
          });
        } else {
          // Mode instantané (changement de thème)
          bgCircle.x = targetX;
          letter.x = targetX;
          self.addContinuousFloatAnimation(bgCircle, letter, targetX, centerY, config.shapeIndex, idx);
        }
      })(this,text[i],i);
    }
  }
  
  // Fonction réutilisable pour les animations continues (le "flottement")
  addContinuousFloatAnimation(bgCircle, letter, targetX, centerY, shapeIndex, idx){
    // Reset les tweens précédents pour le flottement
    this.tweens.killTweensOf([bgCircle, letter]);

    switch(shapeIndex){
      case 0: // Pink: gentle float
        this.tweens.add({targets:bgCircle, y:centerY+8, duration:2000+idx*100, ease:"sine.inout", yoyo:true, repeat:-1});
        this.tweens.add({targets:letter, y:centerY+8, duration:2000+idx*100, ease:"sine.inout", yoyo:true, repeat:-1});
        break;
      case 1: // Blue: vertical spin
        this.tweens.add({targets:bgCircle, y:centerY+15, angle:180, duration:1500, ease:"linear", yoyo:true, repeat:-1});
        this.tweens.add({targets:letter, y:centerY+15, duration:1500, ease:"linear", yoyo:true, repeat:-1});
        break;
      case 2: // Yellow: quick up-down
        this.tweens.add({targets:bgCircle, y:centerY-5, duration:800, ease:"quad.inout", yoyo:true, repeat:-1});
        this.tweens.add({targets:letter, y:centerY-5, duration:800, ease:"quad.inout", yoyo:true, repeat:-1});
        break;
      case 3: // Green: side-to-side (text x,y remains centered)
        this.tweens.add({targets:bgCircle, x:targetX+10, duration:1800, ease:"sine.inout", yoyo:true, repeat:-1});
        this.tweens.add({targets:letter, x:targetX+10, duration:1800, ease:"sine.inout", yoyo:true, repeat:-1});
        break;
      case 4: // Red: rotation
        this.tweens.add({targets:bgCircle, scale:1.1, duration:500, ease:"sine.inout", yoyo:true, repeat:-1});
        this.tweens.add({targets:letter, angle:-360, duration:2000, ease:"linear", repeat:-1});
        break;
    }
  }

  clearAnimatedText(){
    // Cette fonction est appelée par le bouton "Effacer l'historique"
    if(this.letters){
      this.oldLetters = this.letters;
      this.letters = [];
      this.animateOldTextOut(); // Anime la sortie vers la droite
    }
  }

  setupAudio(){
    var self = this;
    try {
      this.popSound = this.sound.add('pop', { loop: false, volume: 0.5 });
    } catch(e){
      console.log('Audio setup skipped');
    }
  }

  playSoundOnce(){
    if(this.popSound){
      try {
        this.popSound.stop();
        this.popSound.play();
      } catch(e){
        console.log('Sound play error');
      }
    }
  }

  setupMouseFleeEffect(){
    var self = this;
    this.input.on('pointermove', function(pointer){
      if(!self.blocks) return;

      self.blocks.getChildren().forEach(function(block){
        var angle = Phaser.Math.Angle.Between(block.x, block.y, pointer.x, pointer.y);
        var distance = Phaser.Math.Distance.Between(block.x, block.y, pointer.x, pointer.y);
        
        // Flee effect - stronger when closer (distance < 1000)
        if(distance < 1000){
          var fleeForce = (1000 - distance) / 100000 * 6000;
          block.x += Math.cos(angle + Math.PI) * fleeForce;
          block.y += Math.sin(angle + Math.PI) * fleeForce;
        }
      });
    });
  }
}

var config = { type: Phaser.AUTO, width: window.innerWidth*0.70, height: window.innerHeight, backgroundColor:'#b8ffb8', parent:'phaser-example', scene:Example, render: { antialias: true } };
new Phaser.Game(config);
</script>

</body>
</html>
