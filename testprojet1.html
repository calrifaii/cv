<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Phaser Shapes + Text Generator — Couleurs & Sons</title>

  <!-- Google Font (cute) -->
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@500;700&display=swap" rel="stylesheet">

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.85.0/dist/phaser.js"></script>

  <style>
    :root{
      --accent: #ff3eb5;
      --bg: #b8ffb8;
      --panel-bg: rgba(255,255,255,0.95);
    }
    html,body{
      height:100%;
      margin:0;
      padding:0;
      font-family: 'Fredoka', Arial, sans-serif;
      background: var(--bg);
      overflow:hidden;
    }

    /* Layout */
    #phaser-example{ width:70vw; height:100vh; float:left; }
    #right-panel{
      width:30vw;
      height:100vh;
      float:right;
      background: var(--panel-bg);
      padding:22px;
      box-sizing:border-box;
      backdrop-filter: blur(6px);
      display:flex;
      flex-direction:column;
      gap:14px;
    }

    h2{
      margin:0;
      color:var(--accent);
      font-size:20px;
      text-align:center;
    }

    #controls{
      display:flex;
      gap:8px;
      justify-content:space-between;
      align-items:center;
    }

    #text-input{
      flex:1;
      padding:10px;
      font-size:16px;
      border-radius:10px;
      border:2px solid var(--accent);
      outline:none;
      box-shadow:none;
    }

    #generate-btn{
      margin-left:8px;
      padding:10px 14px;
      background:var(--accent);
      color:white;
      border:none;
      border-radius:10px;
      font-weight:700;
      cursor:pointer;
    }
    #generate-btn:active{ transform:translateY(1px); }

    /* Color palette */
    .color-palette{
      display:flex;
      gap:10px;
      justify-content:center;
      align-items:center;
    }
    .color-swatch{
      width:36px;
      height:36px;
      border-radius:50%;
      border:3px solid rgba(255,255,255,0.6);
      box-shadow:0 6px 14px rgba(0,0,0,0.12);
      cursor:pointer;
      transition: transform .18s ease, box-shadow .18s ease;
    }
    .color-swatch.selected{
      transform:scale(1.08);
      box-shadow:0 12px 22px rgba(0,0,0,0.2);
      border:3px solid #fff;
    }

    .palette-label{ text-align:center; font-size:12px; color:var(--accent); font-weight:700; text-transform:uppercase; margin-top:4px; }

    /* History */
    .history-section{ flex:1; display:flex; flex-direction:column; gap:8px; overflow:auto; }
    .history-title{ color:var(--accent); font-weight:800; font-size:12px; letter-spacing:1px; text-transform:uppercase; }
    #history-list{ display:flex; flex-direction:column; gap:8px; overflow:auto; padding-right:6px; }
    .history-item{
      padding:8px;
      border-radius:8px;
      background:rgba(255,62,181,0.06);
      border:1px solid rgba(255,62,181,0.12);
      font-size:13px;
      cursor:pointer;
    }
    .history-item.active{ background:var(--accent); color:white; font-weight:700; }

    .clear-history-btn{
      padding:10px; border-radius:10px; border:1px solid var(--accent); color:var(--accent); background:transparent; cursor:pointer; font-weight:700;
    }
    .small-note{ font-size:12px; color:#333; text-align:center; }

    /* Responsive tweak */
    @media(max-width:900px){
      #phaser-example{ width:100vw; height:60vh; }
      #right-panel{ width:100vw; height:40vh; position:fixed; bottom:0; left:0; display:block; overflow:auto; }
    }
  </style>
</head>
<body>

  <div id="phaser-example"></div>

  <div id="right-panel">
    <h2>Créer une animation avec ton texte</h2>

    <div id="controls">
      <input id="text-input" type="text" placeholder="Écris un mot ou une phrase… (max 20)" maxlength="20" />
      <button id="generate-btn">Générer</button>
    </div>

    <div style="display:flex;flex-direction:column;align-items:center;">
      <div class="palette-label">Choisis une couleur</div>
      <div class="color-palette" id="color-palette">
        <!-- JS injects swatches -->
      </div>
    </div>

    <div class="history-section">
      <div class="history-title">Historique</div>
      <div id="history-list"></div>
      <div style="display:flex;gap:8px;margin-top:8px;">
        <button class="clear-history-btn" id="clear-history-btn">Effacer l'historique</button>
      </div>
      <div class="small-note">Clique sur un élément de l'historique pour rejouer l'animation.</div>
    </div>
  </div>


<script>
/*
  Phaser scene with:
  - grid shapes (square/circle/diamond) used as tiles
  - 5 color options, each color selects:
      * text fill / stroke
      * special background shapes animation variant
      * a short generated melody played on click (WebAudio)
  - text enters from left to center quickly
  - previous text exits to the right
  - history list
  - particle click pop and mouse flee
*/

class Example extends Phaser.Scene {
  constructor(){
    super({ key: 'Example' });
    this.history = [];
    this.currentText = '';
    this.letters = [];
    this.blocks = null;
    this.originalPositions = null;
    this.shapes = ['square','circle','diamond'];
    this.phase = 0;
    this.phaseDuration = 6000;
    this.timeSincePhase = 0;
    this.colorMode = null; // will be set externally
    this.audioEngine = null;
    this.musicEnabled = true;
  }

  preload(){
    // Use labs.phaser.io base for misc assets
    this.load.setBaseURL('https://labs.phaser.io');
    this.load.image('spark', 'assets/particles/blue.png');
    // small fx for click (we'll mainly use WebAudio)
    this.load.audio('pop', 'assets/audio/SoundEffects/pop.wav');
  }

  create(){
    // create texture shapes via graphics
    const g = this.make.graphics({ add: false });
    // square
    g.fillStyle(0xffffff, 1);
    g.fillRect(0,0,50,50);
    g.generateTexture('square',50,50);
    // circle
    g.clear();
    g.fillStyle(0xffffff,1);
    g.fillCircle(25,25,25);
    g.generateTexture('circle',50,50);
    // diamond
    g.clear();
    g.fillStyle(0xffffff,1);
    g.beginPath();
    g.moveTo(25,0); g.lineTo(50,25); g.lineTo(25,50); g.lineTo(0,25); g.closePath(); g.fillPath();
    g.generateTexture('diamond',50,50);

    // grid background of shapes
    this.createGrid();

    // particles
    this.particles = this.add.particles('spark');

    // pulsing animation for blocks
    this.setupBlockPulse();

    // sound setup
    this.setupAudio();

    // text engine - UI hooks are outside but will call scene methods; still prepare container
    this.letters = [];
    this.currentText = '';

    // mouse interactions
    this.setupMouseInteractions();

    // default color mode
    // if not set by outside, set to first color
    if(!this.colorMode) this.colorMode = Example.COLORS[0].key;

    // initial shapes coloring according to current color
    this.applyColorModeToShapes(this.colorMode);
  }

  update(time, delta){
    this.timeSincePhase += delta;
    if(this.timeSincePhase > this.phaseDuration){
      this.phase = (this.phase + 1) % this.shapes.length;
      this.timeSincePhase = 0;
      // change texture across grid
      const shapeKey = this.shapes[this.phase];
      this.blocks.getChildren().forEach(b => b.setTexture(shapeKey));
    }

    // animate blocks with pattern depending on phase and color mode
    this.animateBlocks(time);
  }

  createGrid(){
    // fill game area with tiles
    const gameWidth = this.cameras.main.width;
    const gameHeight = this.cameras.main.height;
    const cellW = 60, cellH = 60;
    const cols = Math.ceil(gameWidth / cellW) + 1;
    const rows = Math.ceil(gameHeight / cellH) + 1;
    const total = cols * rows;

    const blocks = this.add.group();
    for(let i=0;i<total;i++){
      const key = this.shapes[i % this.shapes.length];
      const s = this.add.image(0,0,key).setScale(0.36).setAlpha(0.98);
      s.setInteractive({ cursor: 'pointer' });
      blocks.add(s);
    }
    Phaser.Actions.GridAlign(blocks.getChildren(), { width: cols, height: rows, cellWidth: cellW, cellHeight: cellH, x: 0, y: 0 });
    // store
    this.blocks = blocks;
    this.originalPositions = blocks.getChildren().map(b => ({ x: b.x, y: b.y }));

    // block pointer interactions - pop particles on click and slight scale on hover
    const self = this;
    blocks.getChildren().forEach(block => {
      block.on('pointerover', () => {
        self.tweens.add({ targets: block, scale: 0.5, duration: 140, yoyo: true });
      });
      block.on('pointerdown', () => {
        try{ if(self.sound) self.sound.play('pop'); }catch(e){}
        self.particles.createEmitter({ x: block.x, y: block.y, speed: {min:-150,max:150}, lifespan: 500, scale: {start:0.5,end:0}, quantity: 20, tint: Example.COLOR_MAP[this.colorMode].tint }).explode(20, block.x, block.y);
      });
    });
  }

  setupBlockPulse(){
    const children = this.blocks.getChildren();
    for(let i=0;i<children.length;i++){
      this.tweens.add({
        targets: children[i],
        scale: 0.36,
        ease: 'sine.inout',
        duration: 700 + (i%10)*20,
        delay: (i%20)*25,
        yoyo: true,
        repeat: -1
      });
    }
  }

  animateBlocks(time){
    const self = this;
    const children = this.blocks.getChildren();
    const colsApprox = Math.ceil(this.cameras.main.width / 60) + 1;

    children.forEach(function(block, i){
      const orig = self.originalPositions[i];
      let offsetX = 0, offsetY = 0;
      // different patterns by phase
      switch(self.phase){
        case 0:
          offsetX = Math.sin(time/260 + orig.y*0.11)* (12 + self.colorAnimationIntensity());
          offsetY = Math.cos(time/340 + orig.x*0.07)* (8 + self.colorAnimationIntensity()/2);
          break;
        case 1:
          const dx = orig.x - (self.cameras.main.width/2);
          const dy = orig.y - (self.cameras.main.height/2);
          const dist = Math.sqrt(dx*dx + dy*dy);
          offsetX = Math.sin(time/200 + dist*0.04) * (18 + self.colorAnimationIntensity()*1.5);
          offsetY = Math.cos(time/300 + dist*0.02) * (12 + self.colorAnimationIntensity());
          break;
        case 2:
          offsetX = Math.sin(time/220 + (orig.x+orig.y)*0.05) * (15 + self.colorAnimationIntensity());
          offsetY = Math.cos(time/280 + (orig.x-orig.y)*0.04) * (10 + self.colorAnimationIntensity()/1.2);
          break;
      }

      // Add color-specific wiggle or rotation
      const colVariant = Example.COLOR_MAP[self.colorMode].variant;
      if(colVariant === 'twirl') {
        block.rotation = Math.sin(time/1000 + i)*0.6;
      } else if(colVariant === 'bounce') {
        offsetY += Math.sin(time/450 + i*0.02) * 8;
      } else if(colVariant === 'wave') {
        offsetX += Math.sin(time/1800 + i*0.04) * 6;
      } else if(colVariant === 'spin') {
        block.rotation = Math.cos(time/800 + i*0.01) * 0.4;
      } else if(colVariant === 'jitter') {
        offsetX += (Math.random()-0.5) * 2;
        offsetY += (Math.random()-0.5) * 2;
      }

      block.x = orig.x + offsetX;
      block.y = orig.y + offsetY;

      // change tint per color mode for nicer effect
      block.setTint( Example.COLOR_MAP[self.colorMode].tileTint );
      block.setAlpha( Example.COLOR_MAP[self.colorMode].tileAlpha );
    });
  }

  colorAnimationIntensity(){
    // map colorMode to intensity (for variety)
    const m = Example.COLOR_MAP[this.colorMode].intensity || 0;
    return m;
  }

  applyColorModeToShapes(colorKey){
    // apply initial tint/styling for blocks
    if(!this.blocks) return;
    const map = Example.COLOR_MAP[colorKey];
    this.blocks.getChildren().forEach(b => {
      b.setTint(map.tileTint);
      b.setAlpha(map.tileAlpha);
      b.setScale(map.tileScale || 0.36);
    });
  }

  generateAnimatedText(text, colorKey){
    if(!text) return;
    const centerY = this.cameras.main.height / 2;
    const centerX = this.cameras.main.width / 2;

    // If there is existing text on screen, animate it out to the right
    if(this.letters && this.letters.length){
      // group old objects to tween out
      const old = this.letters.slice();
      this.letters = [];
      this.tweens.add({
        targets: old,
        x: `+=${this.cameras.main.width * 0.6}`,
        alpha: 0,
        ease: 'power2.in',
        duration: 450,
        onComplete: function(twn, targets){
          targets.forEach(o => { try { o.destroy(); } catch(e){} });
        }
      });
    }

    // store to history (unique)
    const upText = text.toUpperCase();
    if(!this.history.includes(upText)){
      this.history.unshift(upText);
      if(this.history.length>20) this.history.pop();
      // reflect UI via external hook
      if(window.updateHistoryUI) window.updateHistoryUI(this.history, upText);
    } else {
      // bring chosen text to front in history
      const idx = this.history.indexOf(upText);
      if(idx > -1){
        this.history.splice(idx,1);
        this.history.unshift(upText);
        if(window.updateHistoryUI) window.updateHistoryUI(this.history, upText);
      }
    }

    // set current color mode
    this.colorMode = colorKey || this.colorMode || Example.COLORS[0].key;
    this.applyColorModeToShapes(this.colorMode);

    // play color-specific melody
    if(this.musicEnabled && this.audioEngine) this.audioEngine.playMelodyFor(this.colorMode);

    // compute text sizing
    const charW = 42;
    const totalW = upText.length * charW;
    const startX = -Math.max(200, totalW); // start sufficiently off-screen left

    // create letters each entering from left to final center-based position
    for(let i=0;i<upText.length;i++){
      const ch = upText[i];
      const xPosFinal = centerX - totalW/2 + i * charW + charW/2;
      const yPosFinal = centerY;

      // bg circle behind letter
      const bg = this.add.circle(startX + i*10, yPosFinal, 36, Example.COLOR_MAP[this.colorMode].bgCircle).setDepth(90);
      bg.setAlpha(0.0);
      // letter text
      const letter = this.add.text(startX + i*10, yPosFinal, ch, {
        fontFamily: 'Fredoka, Arial, sans-serif',
        fontSize: '44px',
        fontStyle: '700',
        color: Example.COLOR_MAP[this.colorMode].textColorHex
      }).setOrigin(0.5).setDepth(95);

      // add stroke for clarity
      letter.setStroke(Example.COLOR_MAP[this.colorMode].strokeColorHex || '#FFFFFF', 6);
      letter.setShadow(0,4, 'rgba(0,0,0,0.15)', 6);

      // small pop particle when each letter lands
      const self = this;
      this.tweens.add({
        targets: [bg],
        x: xPosFinal,
        alpha: 0.85,
        scale: { from: 0.6, to: 1.0 },
        ease: 'back.out',
        duration: 360,
        delay: i * 40
      });

      this.tweens.add({
        targets: [letter],
        x: xPosFinal,
        y: yPosFinal - 8,
        alpha: 1,
        angle: 0,
        duration: 420,
        delay: i * 40 + 30,
        ease: 'expo.out',
        onComplete: function(){
          // small particle burst
          self.particles.createEmitter({ x: xPosFinal, y: yPosFinal, speed: {min:-80,max:80}, lifespan: 350, scale: {start:0.4,end:0}, quantity: 8, tint: Example.COLOR_MAP[self.colorMode].tint }).explode(8, xPosFinal, yPosFinal);
        }
      });

      // continuous float on each letter
      this.tweens.add({ targets: [bg, letter], y: yPosFinal + 8, duration: 2200 + i*60, ease: 'sine.inout', yoyo:true, repeat:-1, delay: 420 });

      this.letters.push(bg);
      this.letters.push(letter);
    }

    this.currentText = upText;
    if(window.updateHistoryUI) window.updateHistoryUI(this.history, this.currentText);
  }

  clearAnimatedText(){
    if(this.letters && this.letters.length){
      this.letters.forEach(o => { try{o.destroy();}catch(e){} });
      this.letters = [];
      this.currentText = '';
    }
  }

  setupAudio(){
    // WebAudio generated melodies per color
    this.audioEngine = new AudioEngine();
    // attempt to load pop sound from loaded asset as fallback
    try {
      this.popSound = this.sound.add('pop');
    } catch(e) {
      this.popSound = null;
    }
  }

  playPop(){
    try { if(this.popSound) this.popSound.play(); } catch(e){}
  }

  setupMouseInteractions(){
    const self = this;
    // pointer move - blocks flee from pointer
    this.input.on('pointermove', function(pointer){
      if(!self.blocks) return;
      self.blocks.getChildren().forEach(function(block){
        const angle = Phaser.Math.Angle.Between(block.x, block.y, pointer.x, pointer.y);
        const distance = Phaser.Math.Distance.Between(block.x, block.y, pointer.x, pointer.y);
        if(distance < 900){
          const fleeForce = (900 - distance) / 9000 * 16 * (1 + self.colorAnimationIntensity()/3);
          block.x += Math.cos(angle + Math.PI) * fleeForce;
          block.y += Math.sin(angle + Math.PI) * fleeForce;
        }
      });
    });

    // pointer down drag effect
    this.input.on('pointerdown', function(pointer){
      // small screen ripple: shift originalPositions briefly
      if(self.originalPositions && self.originalPositions.length){
        for(let i=0;i<3;i++){
          const idx = Phaser.Math.Between(0, self.originalPositions.length-1);
          const op = self.originalPositions[idx];
          self.tweens.add({ targets: op, x: op.x + Phaser.Math.Between(-10, 10), y: op.y + Phaser.Math.Between(-10, 10), yoyo: true, duration: 300 });
        }
      }
    });
  }
}

/* ---------- Static color configuration ---------- */
Example.COLORS = [
  { key: 'pink', label: 'Fuchsia', color:'#ff3eb5' },
  { key: 'mint', label: 'Mint', color:'#34d399' },
  { key: 'sun', label: 'Sun', color:'#ffb86b' },
  { key: 'lav', label: 'Lavande', color:'#9b7bff' },
  { key: 'aqua', label: 'Aqua', color:'#00c2ff' }
];

Example.COLOR_MAP = {
  pink:  { tint: 0xff3eb5, tileTint: 0xffc0e8, tileAlpha:0.98, bgCircle: 0xffffff, textColorHex:'#ffffff', strokeColorHex:'#ff3eb5', variant:'twirl', intensity:3 },
  mint:  { tint: 0x34d399, tileTint: 0xc8ffee, tileAlpha:0.95, bgCircle: 0xffffff, textColorHex:'#ffffff', strokeColorHex:'#34a37d', variant:'bounce', intensity:2 },
  sun:   { tint: 0xffb86b, tileTint: 0xffe6c6, tileAlpha:0.96, bgCircle: 0xffffff, textColorHex:'#ffffff', strokeColorHex:'#c87a2b', variant:'wave', intensity:2.2 },
  lav:   { tint: 0x9b7bff, tileTint: 0xe6dbff, tileAlpha:0.95, bgCircle: 0xffffff, textColorHex:'#ffffff', strokeColorHex:'#5d3cff', variant:'spin', intensity:2.6 },
  aqua:  { tint: 0x00c2ff, tileTint: 0xcff5ff, tileAlpha:0.96, bgCircle: 0xffffff, textColorHex:'#ffffff', strokeColorHex:'#007fb3', variant:'jitter', intensity:3.4 }
};

/* ---------- Simple WebAudio engine to produce short melodies per color ---------- */
class AudioEngine {
  constructor(){
    try{
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    }catch(e){
      this.ctx = null;
    }
    // define melodies as sequences of [freq(ms), dur]
    this.melodies = {
      pink: [440, 660, 880, 660],   // simple ascending
      mint: [330, 392, 440, 392],
      sun: [494, 440, 392, 330],
      lav: [262, 330, 392, 523],
      aqua: [220, 262, 330, 392]
    };
  }

  playTone(freq, duration=0.12, when=0){
    if(!this.ctx) return;
    const ctx = this.ctx;
    const t = ctx.currentTime + when;
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = 'sine';
    o.frequency.setValueAtTime(freq, t);
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.18, t + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t + duration);
    o.connect(g);
    g.connect(ctx.destination);
    o.start(t);
    o.stop(t + duration + 0.03);
  }

  playMelodyFor(colorKey){
    if(!this.ctx) return;
    const seq = this.melodies[colorKey] || this.melodies['pink'];
    // play quick arpeggio
    seq.forEach((f, i) => {
      this.playTone(f, 0.1 + (i*0.01), i*0.08);
    });

    // bit of percussion tone
    this.playTone(120, 0.06, seq.length*0.08);
  }
}

/* ---------- Phaser config ---------- */
const config = {
  type: Phaser.AUTO,
  parent: 'phaser-example',
  width: Math.floor(window.innerWidth * 0.70),
  height: window.innerHeight,
  backgroundColor: '#b8ffb8',
  scene: Example,
  render: { antialias: true }
};

const game = new Phaser.Game(config);

/* ---------- External UI interactions (non-scene code) ---------- */

document.addEventListener('DOMContentLoaded', function(){
  const paletteDiv = document.getElementById('color-palette');
  const generateBtn = document.getElementById('generate-btn');
  const textInput = document.getElementById('text-input');
  const historyList = document.getElementById('history-list');
  const clearBtn = document.getElementById('clear-history-btn');

  // Build color swatches
  Example.COLORS.forEach((c, idx) => {
    const sw = document.createElement('div');
    sw.className = 'color-swatch';
    sw.style.background = c.color;
    sw.dataset.key = c.key;
    if(idx === 0) sw.classList.add('selected');
    paletteDiv.appendChild(sw);

    sw.addEventListener('click', () => {
      selectColor(c.key);
    });
  });

  // selectColor function
  function selectColor(key){
    // update UI
    document.querySelectorAll('.color-swatch').forEach(el => el.classList.toggle('selected', el.dataset.key === key));
    // set scene color mode
    const scene = game.scene.keys['Example'];
    if(scene){
      scene.colorMode = key;
      scene.applyColorModeToShapes(key);
      // small sound feedback
      if(scene.audioEngine) scene.audioEngine.playMelodyFor(key);
    }
  }

  // default color selected
  let selectedColor = Example.COLORS[0].key;

  // updateHistoryUI exposed for scene to call
  window.updateHistoryUI = function(historyArray, active){
    historyList.innerHTML = '';
    historyArray.forEach(item => {
      const div = document.createElement('div');
      div.className = 'history-item' + (item === active ? ' active' : '');
      div.textContent = item;
      div.addEventListener('click', () => {
        // call scene to generate
        const scene = game.scene.keys['Example'];
        if(scene){
          scene.generateAnimatedText(item, scene.colorMode || selectedColor);
        }
      });
      historyList.appendChild(div);
    });
  };

  // Generate button
  generateBtn.addEventListener('click', () => {
    const txt = textInput.value.trim();
    if(!txt) return;
    const scene = game.scene.keys['Example'];
    if(scene){
      // determine selected color from UI
      const sw = document.querySelector('.color-swatch.selected');
      const key = sw ? sw.dataset.key : Example.COLORS[0].key;
      scene.generateAnimatedText(txt, key);
      // small pop
      try{ if(scene.popSound) scene.popSound.play(); }catch(e){}
      // clear input
      textInput.value = '';
    }
  });

  // Enter key triggers generate
  textInput.addEventListener('keypress', (e) => {
    if(e.key === 'Enter'){
      generateBtn.click();
    }
  });

  // clear history
  clearBtn.addEventListener('click', () => {
    const scene = game.scene.keys['Example'];
    if(scene){
      scene.history = [];
      scene.clearAnimatedText();
      window.updateHistoryUI([], '');
    }
  });

  // when swatches clicked, update selectedColor local
  paletteDiv.addEventListener('click', (ev) => {
    const el = ev.target.closest('.color-swatch');
    if(!el) return;
    selectedColor = el.dataset.key;
    // also set scene color
    const scene = game.scene.keys['Example'];
    if(scene){
      scene.colorMode = selectedColor;
      scene.applyColorModeToShapes(selectedColor);
    }
  });

  // resize handling (phaser)
  window.addEventListener('resize', () => {
    try{
      const newW = Math.floor(window.innerWidth * 0.70);
      const newH = window.innerHeight;
      game.scale.resize(newW, newH);
      const scene = game.scene.keys['Example'];
      if(scene && scene.originalPositions){
        // recompute layout by destroying and recreating grid quickly
        scene.blocks.getChildren().forEach(b => b.destroy());
        scene.blocks.clear(true);
        scene.createGrid();
        scene.setupBlockPulse();
      }
    }catch(e){}
  });
});

</script>

</body>
</html>
