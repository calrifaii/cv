<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phaser Shapes + Text Generator Pro</title>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.85.0/dist/phaser.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            font-family: 'Inter', Arial, sans-serif;
            overflow: hidden;
            background: #e0f7fa; /* Light cyan background */
        }

        /* Phaser zone */
        #phaser-example {
            width: 70vw;
            height: 100vh;
            border-right: 3px solid #00bcd4; /* Cyan border */
        }

        /* Right-side interface */
        #right-panel {
            width: 30vw;
            height: 100vh;
            background: #ffffff;
            padding: 20px;
            box-sizing: border-box;
            overflow: auto;
            display: flex;
            flex-direction: column;
        }

        #right-panel h2 {
            margin-top: 0;
            color: #00bcd4;
            font-size: 24px;
            text-align: center;
            margin-bottom: 20px;
            font-weight: 800;
        }

        /* Input and Button */
        #text-input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            margin-bottom: 15px;
            border: 2px solid #00bcd4;
            border-radius: 10px;
            outline: none;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        #text-input:focus {
            border-color: #ff5722; /* Orange focus */
            box-shadow: 0 0 12px rgba(0, 188, 212, 0.5);
        }

        #generate-btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(45deg, #ff5722, #ff9800); /* Orange gradient */
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 700;
            box-shadow: 0 5px 15px rgba(255, 87, 34, 0.4);
            margin-bottom: 20px;
            text-transform: uppercase;
        }

        #generate-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(255, 87, 34, 0.6);
        }

        #generate-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(255, 87, 34, 0.4);
        }

        /* Color Selection */
        .color-title {
            font-size: 16px;
            font-weight: 700;
            color: #00bcd4;
            margin-bottom: 10px;
            border-bottom: 2px solid #e0f7fa;
            padding-bottom: 5px;
        }

        #color-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .color-option {
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 3px solid transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
            padding: 5px;
        }

        .color-option[data-color="#FF5722"] {
            background-color: #FF5722;
        } /* Deep Orange */

        .color-option[data-color="#4CAF50"] {
            background-color: #4CAF50;
        } /* Green */

        .color-option[data-color="#2196F3"] {
            background-color: #2196F3;
        } /* Blue */

        .color-option.selected {
            border-color: #ff5722;
            box-shadow: 0 0 0 4px rgba(255, 87, 34, 0.5);
            transform: scale(1.05);
        }

        /* History Section */
        .history-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            margin-top: 10px;
        }

        .history-title {
            font-size: 14px;
            font-weight: 700;
            color: #ff5722;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
        }

        #history-list {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding-right: 5px; /* Space for scrollbar */
        }

        /* Scrollbar styling for a cleaner look */
        #history-list::-webkit-scrollbar {
            width: 6px;
        }

        #history-list::-webkit-scrollbar-track {
            background: #f0f0f0;
            border-radius: 10px;
        }

        #history-list::-webkit-scrollbar-thumb {
            background: #00bcd4;
            border-radius: 10px;
        }

        .history-item {
            padding: 10px;
            background: rgba(0, 188, 212, 0.08);
            border: 1px solid rgba(0, 188, 212, 0.2);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            color: #333;
            word-break: break-word;
            font-weight: 500;
        }

        .history-item:hover {
            background: rgba(0, 188, 212, 0.15);
            border-color: #00bcd4;
            transform: translateX(3px);
        }

        .history-item.active {
            background: #ff5722;
            color: white;
            border-color: #ff5722;
            font-weight: 600;
        }

        .clear-history-btn {
            width: 100%;
            padding: 8px;
            background: rgba(255, 87, 34, 0.1);
            color: #ff5722;
            border: 1px solid #ff5722;
            border-radius: 6px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .clear-history-btn:hover {
            background: #ff5722;
            color: white;
        }
    </style>
</head>
<body>

    <div id="phaser-example"></div>

    <div id="right-panel">
        <h2>Générateur d'Animation Pro</h2>
        <input id="text-input" type="text" placeholder="Écris un mot ou une phrase…" maxlength="20">

        <div class="color-title">1. Choisir la couleur/l'animation</div>
        <div id="color-options">
            <div class="color-option selected" data-color="#FF5722" data-anim="PULSE_WAVE">ORANGE - Vague</div>
            <div class="color-option" data-color="#4CAF50" data-anim="SPIRAL_FLOW">VERT - Spirale</div>
            <div class="color-option" data-color="#2196F3" data-anim="RIPPLE_GRID">BLEU - Ondulation</div>
        </div>

        <button id="generate-btn">Générer l'animation et la musique</button>

        <div class="history-section">
            <div class="history-title">Historique</div>
            <div id="history-list"></div>
            <button class="clear-history-btn" id="clear-history-btn">Effacer l'historique</button>
        </div>
    </div>

    <script>
      
          <script>
class Example extends Phaser.Scene {
    constructor() {
        super();
        this.activeColor = '#FF5722';
        this.activeAnim = 'PULSE_WAVE';

        this.popSound = null;          // VERT (existant)
        this.popSound1 = null;         // ORANGE bouton
        this.popSound2 = null;         // BLEU bouton

        this.hoverSound = null;        // VERT (existant)
        this.hoverSound1 = null;       // ORANGE animation
        this.hoverSound2 = null;       // BLEU animation
    }

    preload() {
        this.load.audio('pop', 'assets/audio/SoundEffects/pop.wav.mp3');
        this.load.audio('pop1', 'assets/audio/SoundEffects/pop.wav1.mp3');
        this.load.audio('pop2', 'assets/audio/SoundEffects/pop.wav2.mp3');

        this.load.audio('hoverGreen', 'assets/audio/SoundEffects/bubble-pop-424583.mp3');
        this.load.audio('hoverOrange', 'assets/audio/SoundEffects/bubble.pop1.mp3');
        this.load.audio('hoverBlue', 'assets/audio/SoundEffects/bubble.pop2.mp3');
    }

    setupAudio() {
        this.popSound  = this.sound.add('pop',  { volume: 0.5 });
        this.popSound1 = this.sound.add('pop1', { volume: 0.5 });
        this.popSound2 = this.sound.add('pop2', { volume: 0.5 });

        this.hoverSound  = this.sound.add('hoverGreen',  { volume: 0.3 });
        this.hoverSound1 = this.sound.add('hoverOrange', { volume: 0.3 });
        this.hoverSound2 = this.sound.add('hoverBlue',   { volume: 0.3 });
    }

    playGenerateSound() {
        if (this.activeAnim === 'SPIRAL_FLOW') this.popSound.play();
        if (this.activeAnim === 'PULSE_WAVE')  this.popSound1.play();
        if (this.activeAnim === 'RIPPLE_GRID') this.popSound2.play();
    }

    playHoverSound(rateAdjust = 0) {
        let sound = this.hoverSound;

        if (this.activeAnim === 'PULSE_WAVE')  sound = this.hoverSound1;
        if (this.activeAnim === 'RIPPLE_GRID') sound = this.hoverSound2;

        sound.play({
            rate: 1 + rateAdjust,
            detune: Phaser.Math.Between(-100, 100)
        });
    }

    setupInteractions() {
        this.blocks.getChildren().forEach(block => {
            block.on('pointerover', pointer => {
                let speed = this.input.activePointer.velocity.length();
                let rateAdjust = Phaser.Math.Clamp(speed / 600, 0, 1.5);
                this.playHoverSound(rateAdjust);
            });
        });
    }

    createTextEngine() {
        const button = document.getElementById("generate-btn");
        const input = document.getElementById("text-input");

        button.addEventListener("click", () => {
            if (!input.value.trim()) return;
            this.generateAnimatedTextBlock(input.value.toUpperCase());
            this.playGenerateSound();
            input.value = '';
        });
    }


            create() {
                this.generateTextures();
                this.createBlocks();
                this.setupAudio(); // Initialisation des objets Audio
                this.setupInteractions();
                this.createTextEngine();
                window.addEventListener('resize', this.handleResize.bind(this));
                this.handleResize();
            }

            handleResize() {
                const newWidth = window.innerWidth * 0.70;
                const newHeight = window.innerHeight;
                this.game.scale.resize(newWidth, newHeight);
                this.recalculateGrid(newWidth, newHeight);

                // Recentrer le bloc de texte animé
                if (this.textObject) {
                    this.textObject.setPosition(this.cameras.main.width / 2, this.cameras.main.height / 2);
                    this.textBg.setPosition(this.cameras.main.width / 2, this.cameras.main.height / 2);
                }
            }

            generateTextures() {
                if (this.textures.exists('square')) return;

                var g = this.make.graphics({ x:0, y:0, add:false });

                // --- Square ---
                g.fillStyle(0xffffff, 1);
                g.fillRect(0, 0, 50, 50);
                g.generateTexture('square', 50, 50);

                // --- Circle ---
                g.clear();
                g.fillStyle(0xffffff, 1);
                g.fillCircle(25, 25, 25);
                g.generateTexture('circle', 50, 50);

                // --- Diamond ---
                g.clear();
                g.fillStyle(0xffffff, 1);
                g.beginPath();
                g.moveTo(25, 0);
                g.lineTo(50, 25);
                g.lineTo(25, 50);
                g.lineTo(0, 25);
                g.closePath();
                g.fillPath();
                g.generateTexture('diamond', 50, 50);

                g.destroy();
                this.shapes = ['square', 'circle', 'diamond'];
            }

            createBlocks() {
                if (this.blocks) return;

                var gameWidth = this.cameras.main.width;
                var gameHeight = this.cameras.main.height;
                var cellWidth = 60;
                var cellHeight = 60;
                var cols = Math.ceil(gameWidth / cellWidth) + 1;
                var rows = Math.ceil(gameHeight / cellHeight) + 1;
                var totalBlocks = cols * rows;

                this.cols = cols;
                this.rows = rows;
                this.blocks = this.add.group();

                for (var i = 0; i < totalBlocks; i++) {
                    var key = this.shapes[i % this.shapes.length];
                    var tintValue = Phaser.Display.Color.HexStringToColor(this.activeColor).color;
                    var sprite = this.add.image(0, 0, key).setScale(0.3).setTint(tintValue);
                    sprite.setInteractive();
                    sprite.offsetX = 0;
                    sprite.offsetY = 0;
                    this.blocks.add(sprite);
                }

                Phaser.Actions.GridAlign(this.blocks.getChildren(), {
                    width: cols,
                    height: rows,
                    cellWidth: cellWidth,
                    cellHeight: cellHeight,
                    x: 0,
                    y: 0
                });

                this.originalPositions = this.blocks.getChildren().map(function(b){
                    return { x: b.x, y: b.y };
                });

                this.applyPulseTween();
            }

            recalculateGrid(width, height) {
                if (!this.blocks) return;

                var gameWidth = width || this.cameras.main.width;
                var gameHeight = height || this.cameras.main.height;
                var cellWidth = 60;
                var cellHeight = 60;
                var cols = Math.ceil(gameWidth / cellWidth) + 1;
                var rows = Math.ceil(gameHeight / cellHeight) + 1;

                Phaser.Actions.GridAlign(this.blocks.getChildren(), {
                    width: cols,
                    height: rows,
                    cellWidth: cellWidth,
                    cellHeight: cellHeight,
                    x: 0,
                    y: 0
                });

                this.originalPositions = this.blocks.getChildren().map(function(b){
                    return { x: b.x, y: b.y };
                });

                this.cols = cols;
                this.rows = rows;
            }

            applyPulseTween() {
                this.blocks.getChildren().forEach(block => this.tweens.killTweensOf(block));

                var children = this.blocks.getChildren();

                children.forEach((child, idx) => {
                    this.tweens.add({
                        targets: child,
                        scale: 0.35,
                        ease: 'sine.inout',
                        duration: 600,
                        delay: (idx % this.cols) * 40,
                        yoyo: true,
                        repeat: -1
                    });
                });
            }

            setupInteractions() {
                var self = this;

                this.blocks.getChildren().forEach(function(block){
                    
                    // --- CHANGED: Dynamic Audio Rate based on speed ---
                    block.on('pointerover', function(pointer){
                        self.tweens.add({targets:block, scale:0.5, duration:150, yoyo:true});
                        
                        if(self.hoverSound) {
                            // Calculate mouse speed
                            // pointer is passed to the event, we check velocity
                            let speed = self.input.activePointer.velocity.length();
                            
                            // Map speed to rate. 
                            // Speed usually 0-2000+. 
                            // Rate 1.0 = normal. Rate 2.0 = fast/high pitch.
                            // We start at 1.0 and add up to 1.5 based on speed.
                            let rateAdjust = Phaser.Math.Clamp(speed / 600, 0, 1.5);

                            self.hoverSound.play({ 
                                volume: 0.3, 
                                // Faster speed = Higher rate = "More Rapid" sound
                                rate: 1.0 + rateAdjust, 
                                detune: Phaser.Math.Between(-100, 100) + (rateAdjust * 300)
                            });
                        }
                    });

                    block.on('pointerdown', function(){
                        if(self.particles) { 
                            self.particles.createEmitter({
                                x: block.x,
                                y: block.y,
                                speed: { min: -150, max: 150 },
                                lifespan: 500,
                                scale: { start: 0.5, end: 0 },
                                quantity: 20,
                                tint: Phaser.Display.Color.HexStringToColor(self.activeColor).color
                            }).explode(20, block.x, block.y);
                        }
                    });
                });

                this.input.on('pointermove', function(pointer){
                    if(!self.blocks) return;

                    self.blocks.getChildren().forEach(function(block){
                        var angle = Phaser.Math.Angle.Between(block.x, block.y, pointer.x, pointer.y);
                        var distance = Phaser.Math.Distance.Between(block.x, block.y, pointer.x, pointer.y);

                        if(distance < 200){
                            var fleeForce = (200 - distance) / 200 * 5;
                            block.offsetX = (block.offsetX || 0) + Math.cos(angle + Math.PI) * fleeForce;
                            block.offsetY = (block.offsetY || 0) + Math.sin(angle + Math.PI) * fleeForce;
                        }
                    });
                });
            }

            update(time, delta) {
                this.timeSincePhase += delta;

                if(this.timeSincePhase > this.phaseDuration){
                    this.phase = (this.phase + 1) % this.shapes.length;
                    this.timeSincePhase = 0;
                    var newShape = this.shapes[this.phase];
                    var self = this;

                    this.blocks.getChildren().forEach((block, index) => {
                        this.tweens.add({
                            targets: block,
                            scale: 0,
                            duration: 250,
                            delay: index % 5 * 20,
                            onComplete: function(){
                                block.setTexture(newShape);
                                self.tweens.add({
                                    targets: block,
                                    scale: 0.3,
                                    duration: 300,
                                    ease: 'Back.easeOut'
                                });
                            }
                        });
                    });
                }

                this.animateBlocks(time);
            }

            animateBlocks(time) {
                var self = this;
                this.blocks.getChildren().forEach(function(block, i){
                    var orig = self.originalPositions[i];
                    var offsetX = 0, offsetY = 0;
                    var centerW = self.cameras.main.width / 2;
                    var centerH = self.cameras.main.height / 2;

                    switch(self.activeAnim){
                        case 'PULSE_WAVE':
                            offsetX = Math.sin(time / 350 + orig.y * 0.1) * 15;
                            offsetY = Math.cos(time / 450 + orig.x * 0.08) * 10;
                            break;

                        case 'SPIRAL_FLOW':
                            var dx = orig.x - centerW;
                            var dy = orig.y - centerH;
                            var dist = Math.sqrt(dx * dx + dy * dy);
                            var angle = Math.atan2(dy, dx) + time * 0.0005;
                            offsetX = Math.cos(angle) * (dist * 0.1) + Math.sin(time / 200 + i * 0.1) * 5;
                            offsetY = Math.sin(angle) * (dist * 0.1) + Math.cos(time / 300 + i * 0.1) * 5;
                            break;

                        case 'RIPPLE_GRID':
                            var dx = orig.x - centerW;
                            var dy = orig.y - centerH;
                            var dist = Phaser.Math.Distance.Between(orig.x, orig.y, centerW, centerH);
                            var ripple = Math.sin(time / 200 + dist * 0.02) * 8;
                            offsetX = (dx / dist) * ripple;
                            offsetY = (dy / dist) * ripple;
                            break;
                    }

                    block.x = orig.x + offsetX + (block.offsetX || 0);
                    block.y = orig.y + offsetY + (block.offsetY || 0);

                    block.offsetX = (block.offsetX || 0) * 0.95;
                    block.offsetY = (block.offsetY || 0) * 0.95;
                });
            }

            createTextEngine() {
                var input = document.getElementById("text-input");
                var button = document.getElementById("generate-btn");
                var colorOptions = document.querySelectorAll('.color-option');
                var self = this;

                // 1. Gestion des options de couleur
                colorOptions.forEach(option => {
                    option.addEventListener('click', function() {
                        colorOptions.forEach(opt => opt.classList.remove('selected'));
                        this.classList.add('selected');

                        self.activeColor = this.getAttribute('data-color');
                        self.activeAnim = this.getAttribute('data-anim');

                        const tintValue = Phaser.Display.Color.HexStringToColor(self.activeColor).color;
                        self.blocks.getChildren().forEach(block => block.setTint(tintValue));

                        // Mettre à jour si le texte existe déjà
                        if (self.textObject && self.textBg) {
                            self.textObject.setColor(self.activeColor);
                            // On doit redessiner le background "pro" avec la nouvelle couleur de bordure
                            self.redrawProBackground(self.textBg, self.textObject.width, self.textObject.height, tintValue);
                            self.applyTextBlockAnimation(self.activeAnim);
                        }
                    });
                });

                // 2. Gestion du bouton Générer
                button.addEventListener("click", function() {
                    var text = input.value.toUpperCase().trim();
                    if (!text) return;

                    if (!self.history.includes(text)) {
                        self.history.push(text);
                    }
                    
                    self.updateHistoryUI();
                    self.generateAnimatedTextBlock(text);
                    self.currentAnimationText = text;

                    if (self.popSound) {
                        try {
                            self.popSound.play();
                        } catch(e) {
                            console.log('Error playing pop sound.');
                        }
                    }

                    self.startBackgroundMusic();
                    input.value = '';
                });

                input.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        button.click();
                    }
                });

                // 3. Gestion du bouton Effacer l'historique
                document.getElementById("clear-history-btn").addEventListener("click", function(){
                    self.history = [];
                    self.updateHistoryUI();
                    self.clearAnimatedTextBlock();
                    self.stopBackgroundMusic();
                });

                this.updateHistoryUI();
            }

            updateHistoryUI() {
                var historyList = document.getElementById("history-list");
                historyList.innerHTML = '';
                var self = this;

                this.history.forEach(function(text){
                    var item = document.createElement('div');
                    item.className = 'history-item';
                    if(text === self.currentAnimationText){
                        item.classList.add('active');
                    }
                    item.textContent = text;
                    item.addEventListener('click', function(){
                        self.activeColor = document.querySelector('.color-option.selected').getAttribute('data-color');
                        self.activeAnim = document.querySelector('.color-option.selected').getAttribute('data-anim');

                        self.generateAnimatedTextBlock(text);
                        self.currentAnimationText = text;
                        self.updateHistoryUI();
                        self.startBackgroundMusic();

                        if (self.popSound) {
                            try {
                                self.popSound.play();
                            } catch(e) {
                                console.log('Error playing pop sound from history.');
                            }
                        }
                    });
                    historyList.appendChild(item);
                });
            }

            // --- CHANGED: Utilisation de Graphics pour un look "Pro" ---
            generateAnimatedTextBlock(text) {
                this.clearAnimatedTextBlock();

                var centerX = this.cameras.main.width / 2;
                var centerY = this.cameras.main.height / 2;
                const letterColor = this.activeColor;
                const tint = Phaser.Display.Color.HexStringToColor(letterColor).color;

                // 1. Calculate text dimensions without showing it yet
                var tempText = this.add.text(0, 0, text, {
                    fontFamily: 'Inter',
                    fontSize: '60px',
                    color: letterColor,
                    fontWeight: '900'
                }).setOrigin(0.5).setVisible(false);
                
                const txtW = tempText.width;
                const txtH = tempText.height;
                tempText.destroy();

                // 2. Create "Pro" Background using Graphics instead of Rectangle
                this.textBg = this.add.graphics();
                this.textBg.setDepth(99);
                this.textBg.setPosition(centerX, centerY); // Center the graphics object
                
                // Draw the rounded box
                this.redrawProBackground(this.textBg, txtW, txtH, tint);

                // 3. Objet Texte
                this.textObject = this.add.text(centerX, centerY, text, {
                    fontFamily: 'Inter',
                    fontSize: '60px',
                    color: letterColor,
                    fontWeight: '900'
                }).setOrigin(0.5).setDepth(100);

                // Animation d'entrée
                this.tweens.add({
                    targets: [this.textBg, this.textObject],
                    scale: { from: 0.1, to: 1 },
                    alpha: { from: 0, to: 1 },
                    duration: 1200,
                    ease: "Elastic.easeOut",
                    onComplete: () => {
                        this.applyTextBlockAnimation(this.activeAnim);
                    }
                });
            }

            // Helper to draw the fancy rounded box
            redrawProBackground(graphics, txtW, txtH, strokeColor) {
                if(!graphics) return;
                graphics.clear();
                
                const paddingX = 40;
                const paddingY = 30;
                const w = txtW + paddingX * 2;
                const h = txtH + paddingY * 2;
                const radius = 30; // Rounded corners for "Pro" look

                // Drop Shadow (Black with transparency, slight offset)
                graphics.fillStyle(0x000000, 0.2);
                graphics.fillRoundedRect(-w/2 + 8, -h/2 + 8, w, h, radius);

                // Main Card Body (White, slightly transparent for glass effect)
                graphics.fillStyle(0xffffff, 0.95);
                graphics.fillRoundedRect(-w/2, -h/2, w, h, radius);

                // Border (Stroke)
                graphics.lineStyle(4, strokeColor, 1);
                graphics.strokeRoundedRect(-w/2, -h/2, w, h, radius);
            }

            applyTextBlockAnimation(animKey) {
                if (!this.textObject) return;

                this.tweens.killTweensOf(this.textObject);
                this.tweens.killTweensOf(this.textBg);

                var targets = [this.textObject, this.textBg];
                var centerX = this.cameras.main.width / 2;
                var centerY = this.cameras.main.height / 2;

                targets.forEach(t => t.setPosition(centerX, centerY).setAngle(0).setScale(1)); 

                switch (animKey) {
                    case 'PULSE_WAVE':
                        this.tweens.add({
                            targets: targets,
                            y: centerY + 15,
                            duration: 2500,
                            ease: "sine.inout",
                            yoyo: true,
                            repeat: -1
                        });
                        this.tweens.add({
                            targets: targets,
                            scale: 1.05,
                            duration: 1000,
                            ease: "power1",
                            yoyo: true,
                            repeat: -1
                        });
                        break;

                    case 'SPIRAL_FLOW':
                        this.tweens.add({
                            targets: targets,
                            angle: { from: -5, to: 5 },
                            duration: 4000,
                            ease: "sine.inout",
                            yoyo: true,
                            repeat: -1
                        });
                        this.tweens.add({
                            targets: targets,
                            x: centerX + 20,
                            duration: 3000,
                            ease: "sine.inout",
                            yoyo: true,
                            repeat: -1
                        });
                        break;

                    case 'RIPPLE_GRID':
                        this.tweens.add({
                            targets: targets,
                            scale: 1.1,
                            duration: 800,
                            ease: "sine.in",
                            yoyo: true,
                            repeat: -1
                        });
                        break;
                }
            }

            clearAnimatedTextBlock() {
                if (this.textObject) {
                    this.tweens.killTweensOf(this.textObject);
                    this.textObject.destroy();
                    this.textObject = null;
                }
                if (this.textBg) {
                    this.tweens.killTweensOf(this.textBg);
                    this.textBg.destroy();
                    this.textBg = null;
                }
            }

            setupAudio(){
                var self = this;
                try {
                    this.popSound = this.sound.add('pop', { loop: false, volume: 0.5 });
                    // Init new hover sound
                    this.hoverSound = this.sound.add('hoverPop', { loop: false, volume: 0.3 });
                } catch(e){
                    console.log('Audio setup skipped or failed. Error:', e);
                }
            }

            startBackgroundMusic() {
                if (this.bgMusic) {
                    try {
                        if (this.bgMusic.isPlaying) {
                            this.bgMusic.stop();
                        }
                        this.bgMusic.play();
                    } catch(e) {
                        console.log('Error playing music.');
                    }
                }
            }

            stopBackgroundMusic() {
                if (this.bgMusic && this.bgMusic.isPlaying) {
                    try {
                        this.bgMusic.stop();
                    } catch(e) {
                        console.log('Error stopping music.');
                    }
                }
            }
        }

        var config = {
            type: Phaser.AUTO,
            width: window.innerWidth * 0.70,
            height: window.innerHeight,
            backgroundColor: '#e0f7fa',
            parent: 'phaser-example',
            scene: Example,
            render: {
                antialias: true
            }
        };

        new Phaser.Game(config);
    </script>

</body>
</html>
